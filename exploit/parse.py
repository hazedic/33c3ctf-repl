#!/usr/bin/env python3

from collections import namedtuple
from struct import unpack, Struct
import sys

indent = 0

def dump(*args):
    if len(args) > 0:
        print(indent * ' ', *args)
    else:
        print('')

Header = Struct('=4s B B 6s B B B B B q d')
FunctionMetadata = Struct('=i i b b b')

def parse_string(data):
    if data[0] == 0:
        return b'', data[1:]
    elif data[0] < 0xff:
        length = data[0] - 1
        data = data[1:]
    else:
        length = unpack('=Q', data[1:9])[0] - 1
        data = data[9:]
    string = data[:length]
    return string, data[length:]

def disassemble(code):
    def Op(instr):
        return instr & 0x3f
    def A(instr):
        return (instr >> 6) & 0xff
    def B(instr):
        return (instr >> 14) & 0x1ff
    def C(instr):
        return (instr >> 23) & 0x1ff
    def Ax(instr):
        return (instr >> 6) & 0x3ffffff
    def Bx(instr):
        return (instr >> 14) & 0x3ffff
    def sBx(instr):
        return Bx(instr) - 2**17

    handlers = [
            ('MOVE    ', A, B),
            ('LOADK   ', A, Bx),
            ('LOADKX  ', A),
            ('LOADBOOL', A, B, C),
            ('LOADNIL ', A, B),
            ('GETUPVAL', A, B),

            ('GETTABUP', A, B, C),
            ('GETTABLE', A, B, C),

            ('SETTABUP', A, B, C),
            ('SETUPVAL', A, B),
            ('SETTABLE', A, B, C),

            ('NEWTABLE', A, B, C),

            ('SELF    ', A, B, C),

            ('ADD     ', A, B, C),
            ('SUB     ', A, B, C),
            ('MUL     ', A, B, C),
            ('MOD     ', A, B, C),
            ('POW     ', A, B, C),
            ('DIV     ', A, B, C),
            ('IDIV    ', A, B, C),
            ('BAND    ', A, B, C),
            ('BOR     ', A, B, C),
            ('BXOR    ', A, B, C),
            ('SHL     ', A, B, C),
            ('SHR     ', A, B, C),
            ('UNM     ', A, B),
            ('BNOT    ', A, B),
            ('NOT     ', A, B),
            ('LEN     ', A, B),

            ('CONCAT  ', A, B, C),

            ('JMP     ', A, sBx),
            ('EQ      ', A, B, C),
            ('LT      ', A, B, C),
            ('LE      ', A, B, C),

            ('TEST    ', A, C),
            ('TESTSET ', A, B, C),

            ('CALL    ', A, B, C),
            ('TAILCALL', A, B, C),
            ('RETURN  ', A, B),

            ('FORLOOP ', A, sBx),
            ('FORPREP ', A, sBx),

            ('TFORCALL', A, C),
            ('TFORLOOP', A, sBx),

            ('SETLIST ', A, B, C),

            ('CLOSURE ', A, Bx),

            ('VARARG  ', A, B),

            ('EXTRAARG', Ax),
    ]

    for instr in code:
        op = Op(instr)
        if op < len(handlers):
            name, *args = handlers[op]
            args = [str(arg(instr)).ljust(9) for arg in args]
            dump("{}     {}".format(name, ' '.join(args)))
        else:
            dump("Unknown opcode {}".format(op))


def parse_code(data):
    codesize = unpack('=I', data[:4])[0]
    data = data[4:]

    dump("Codesize           : ", codesize)
    dump()

    code = []
    for _ in range(codesize):
        if len(data) < 4:
            dump("Error: codesize too large")
            break
        instr = unpack('=I', data[:4])[0]
        data = data[4:]
        code.append(instr)

    dump("--- Code ---")
    disassemble(code)

    return data

def parse_constants(data):
    dump()
    dump("--- Contants ---")

    num_constants = unpack('=i', data[:4])[0]
    data = data[4:]

    dump("Num constants      : ", num_constants)
    dump()


    LUA_TNIL           = 0
    LUA_TBOOLEAN       = 1
    LUA_TLIGHTUSERDATA = 2
    LUA_TNUMBER        = 3
    LUA_TSTRING        = 4
    LUA_TTABLE         = 5
    LUA_TFUNCTION      = 6
    LUA_TUSERDATA      = 7
    LUA_TTHREAD        = 8

    LUA_TSHRSTR	= LUA_TSTRING | (0 << 4)
    LUA_TLNGSTR	= LUA_TSTRING | (1 << 4)

    LUA_TNUMFLT	= LUA_TNUMBER | (0 << 4)
    LUA_TNUMINT	= LUA_TNUMBER | (1 << 4)

    for _ in range(num_constants):
        ttype = data[0]
        data = data[1:]
        if ttype == LUA_TNIL:
            dump("Nil")
        elif ttype == LUA_TBOOLEAN:
            dump("Boolean {}".format(data[0]))
            data = data[1:]
        elif ttype == LUA_TNUMFLT:
            val = unpack('=d', data[:8])[0]
            data = data[8:]
            dump("Number {}".format(val))
        elif ttype == LUA_TNUMINT:
            val = unpack('=q', data[:8])[0]
            data = data[8:]
            dump("Number {}".format(val))
        elif ttype == LUA_TSHRSTR or ttype == LUA_TLNGSTR:
            val, data = parse_string(data)
            dump("String {}".format(val))
        else:
            dump("Unknown Value: {}".format(hex(ttype)))

    return data

def parse_upvalues(data):
    dump()
    dump("--- Upvalues ---")

    num_upvals = unpack('=i', data[:4])[0]
    data = data[4:]

    dump("Num Upvalues       : ", num_upvals)

    for _ in range(num_upvals):
        instack, idx = data[0], data[1]
        data = data[2:]
        dump("{} {}".format(instack, idx))

    return data

def parse_protos(data):
    global indent
    dump()
    dump("--- Functions ---")

    num_functions = unpack('=i', data[:4])[0]
    data = data[4:]

    dump("Num Functions      : ", num_functions)

    indent += 4
    for _ in range(num_functions):
        data = parse_function(data)
    indent -= 4

    return data

def parse_debug(data):
    dump()
    dump("--- Debug ---")

    dump(" -- Lineinfo -- ")
    num_lineinfo = unpack('=i', data[:4])[0]
    data = data[4:]
    dump("Num lineinfos      : ", num_lineinfo)
    for _ in range(num_lineinfo):
        line = unpack('=I', data[:4])[0]
        data = data[4:]
        dump(line)

    dump(" -- Localvars -- ")
    num_localvars = unpack('=i', data[:4])[0]
    data = data[4:]
    dump("Num localvars      : ", num_localvars)
    for _ in range(num_localvars):
        string, data = parse_string(data)
        startpc, endpc = unpack('=I I', data[:8])
        data = data[8:]
        dump(string, startpc, endpc)

    dump(" -- Upvals -- ")
    num_upvals = unpack('=i', data[:4])[0]
    data = data[4:]
    dump("Num upvals         : ", num_upvals)
    for _ in range(num_upvals):
        string, data = parse_string(data)
        dump(string)

    return data

def parse_function(data):
    dump("--- Function ---")

    source, data = parse_string(data)

    metadata = FunctionMetadata.unpack(data[:FunctionMetadata.size])
    data = data[FunctionMetadata.size:]

    dump("Source             : ", source)
    dump("Line               : ", metadata[0])
    dump("Last Line          : ", metadata[1])
    dump("Number of params   : ", metadata[2])
    dump("Is Vararg          : ", metadata[3])
    dump("Max. Stacksize     : ", metadata[4])
    dump()

    data = parse_code(data)
    data = parse_constants(data)
    data = parse_upvalues(data)
    data = parse_protos(data)
    data = parse_debug(data)

    return data

def parse_header(data):
    header = Header.unpack(data[:Header.size])

    dump("--- Header ---")
    dump("Signature          : ", header[0])
    dump("Version            : ", header[1])
    dump("Format             : ", header[2])
    dump("Data               : ", header[3])
    dump("int size           : ", header[4])
    dump("size_t size        : ", header[5])
    dump("Instruction size   : ", header[6])
    dump("Lua Integer size   : ", header[7])
    dump("Lua Number size    : ", header[8])
    dump("LUAC_INT           : ", hex(header[9]))
    dump("LUAC_NUM           : ", header[10])
    dump()

    return data[Header.size:]

def parse_chunk(data):
    data = parse_header(data)

    num_upvals = data[0]
    data = data[1:]
    dump("Number of Upvalues : ", num_upvals)
    dump()

    data = parse_function(data)
    assert(len(data) == 0)

if __name__ == '__main__':
    if len(sys.argv) < 2:
        print("Usage: {} code.luac".format(sys.argv[0]))
        sys.exit(1)

    data = open(sys.argv[1], 'rb').read()

    parse_chunk(data)
